# This file contains the main functions exported by the CS3 package.

#' Compare PARAFAC and EEM spectra with spectral similarity metrics
#'
#' @description Extract the spectra from a PARAFAC model (B and C mode loadings) and compare them with underlying
#'       sample data. Various options exist for corrections, including adjusting excitation spectra so that SSC might
#'       be applied rather than just TCC.
#'
#' @param pfmodel a PARAFAC model object. An output from staRdom::eem_parafac()
#' @param eemlist a group of EEMs compliant with the staRdom/EEM/eemR package framework
#' @param comp numeric, singular - the target component for comparisons
#' @param MQL_eem an EEM object quantifying the Method Quantification Limit. Generated by suppling create_MQL_eem with an eemlist comprising ultrapure water blanks generated with the same instrument + method as the EEMs supplied to this function and the target PARAFAC model.
#' @param denormalise_loadings_MQL was the pfmodel used here supplied with normalised EEMs, and do you wish to denormalised them? This requires the eemlist supplied to per_eem_ssc to be non-normalised.
#' @param tcc TRUE/FALSE to extract only TCC rather than SSC
#' @param terms TRUE/FALSE to extract the alpha and beta penalty term values alongside SSC
#' @param modified_metrics TRUE/FALSE to add the modified (ex + em combined) TCC and SSC metrics after Parr et al., 2014.
#' @param spectral_correct either NULL, 'all', 'ex', or 'em'. Subtract the loadings of other components from the raw sample spectra of the type specified
#' @param interp_1nm either NULL, 'all', 'ex', or 'em'.  Interpolate spectra to 1nm bandwidths. Recommended. Applied after spectral correction
#' @param smooth_sg either NULL, 'all', 'ex', or 'em'. Applies a Savitzky-Golay filter to the data prior to metric calculation. Only recommended if interpolation is performed. Uses signal::sgolay(). Default values are a 2nd order polynomial, n = 21 for emission spectra and n = 11 for excitation spectra.
#' @param complete_peak either NULL, 'all', 'ex', or 'em'. Use a gradient detection method to identify incomplete peaks in spectra, and prevent them from interfering with the SSC peak position calculation. Set options with the parameter 'SSC_trim_method'.
#' @param SSC_trim_method if !is.null(complete_peak), choose one of either 'mod_alpha' to alter the peak position penalty term, or 'trim_spectra' to remove the incomplete peak entirely
#' @param verbose TRUE/FALSE to return various messages during the function's opperation. Useful for error checking or to keep track of how things are proceeding. Only used for spectral correction.
#' @param denormalise_residuals TRUE/FALSE to denormalise residuals using the max fluorescence value of the supplied eemlist. Default to FALSE. Use if you're supplying a PARAFAC model to the function that was generated with a normalised version of an eemlist, and comparing it with the non-normalised version of said eemlist.
#' @param exclude_negative_residuals TRUE/FALSE to set negative values to 0 during component overlap correction. Setting this to TRUE may inflate similarity scores in component:sample comparisons where the model has over-fitted the component.
#' @param constrain_comparison TRUE/FALSE or numeric decimal value between 0 and 1. A percentage threshold is used to identify the 'limit' of a component's fluorescence response, limiting spectral comparisons to within the normalised intensity boundary supplied.
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr select
#' @importFrom dplyr mutate_at
#' @importFrom dplyr vars
#' @importFrom dplyr filter
#' @importFrom utils data
#' @importFrom tibble column_to_rownames
#'
#' @export
#'

per_eem_ssc <- function(pfmodel,
                        eemlist,
                        comp,
                        MQL_eem = NULL,
                        denormalise_loadings_MQL = FALSE,
                        tcc = FALSE,
                        modified_metrics = TRUE,
                        spectral_correct = "all",
                        interp_1nm = "all",
                        smooth_sg = "all",
                        complete_peak = "ex",
                        SSC_trim_method = 'mod_alpha',
                        verbose = FALSE,
                        denormalise_residuals = FALSE,
                        exclude_negative_residuals = FALSE,
                        constrain_comparison = FALSE){
  ## PREP PF SPECTRA
  # get PARAFAC spectra
  pf_peak_spectra <- extrpf_peak_spectra_int(pfmodel, component = comp)
  # get PARAFAC Emission 'B' mode - emission
  mat_pf_em_main <- as.matrix(pfmodel$B[,comp])
  # get PARAFAC Excitation 'C' mode - excitation
  mat_pf_ex_main <- as.matrix(pfmodel$C[,comp])
  ## PF SPECTRA INTERPOLATION Interpolate PARAFAC spectra, if specified.
  if(!is.null(interp_1nm)){
    if(isTRUE(verbose)){
      message("Interpolating PARAFAC spectra, type: ", interp_1nm)
    }
    if(interp_1nm == "ex"){
      mat_pf_ex_main <- interpolate_matrix_1nm(mat = mat_pf_ex_main, mat_out = TRUE)
    } else if(interp_1nm == "em"){
      mat_pf_em_main <- interpolate_matrix_1nm(mat = mat_pf_em_main, mat_out = TRUE)
    } else if(interp_1nm == "all"){
      mat_pf_ex_main <- interpolate_matrix_1nm(mat = mat_pf_ex_main, mat_out = TRUE)
      mat_pf_em_main <- interpolate_matrix_1nm(mat = mat_pf_em_main, mat_out = TRUE)
    } else {
      stop("Please specify interp_1nm as NULL, 'ex', 'em' or 'all'")
    }
  }
  # Confirm only one component was extracted
  if(length(unique(pf_peak_spectra$max_ex)) > 1 | length(unique(pf_peak_spectra$max_em)) > 1 ){
    message("Oops! More than one spectra extracted. There's something off with the PARAFAC peak spectra.")
  }
  # Get target wavelength pair
  target_em <- pf_peak_spectra$max_em[1]
  target_ex <- pf_peak_spectra$max_ex[1]
  ## RESIDUALS EXTRACTION. If correcting spectra, extract the residuals and ex/em grobs.
  if(!is.null(spectral_correct)){
    if(isTRUE(verbose)){
      message("Extracting residuals data for component overlap correction...")
    }
    residuals <- extrpf_residuals_int(pfmodel = pfmodel, eem_list = eemlist, denormalise = denormalise_residuals, verbose = verbose)
    # Get the grobs for ex and em
    grob_ex <- residuals[which(residuals$em == target_em),]
    grob_em <-  residuals[which(residuals$ex == target_ex),]
    if(isTRUE(verbose)){
      message("Residuals extracted.")
    }
  }
  ## LIMIT OF QUANTIFICATION HANDLING
  # Compare MQL EEM and PFMODEL. Are they sufficiently similar?
  if(!is.null(MQL_eem)){
    if(class(MQL_eem) != 'eem'){
      stop('MQL_eem must be an object of class "eem"')
    }
    dimcheck <- compare_dims_eem_pf(pfmodel = pfmodel, eem = MQL_eem)
    if(!all(dimcheck$Pass)){
      message("Comparison of pfmodel and background/MQL/MDL EEM:")
      print(dimcheck)
      stop("!! PARAFAC model and MQL EEM exhibit ex/em differences, implying a difference in methods.")
    }
    # If they are sufficiently similar, but there is a minor difference in emission increments, we can forge ahead:
    if(!setequal(as.numeric(MQL_eem$em), as.numeric(rownames(pfmodel$B)))){
      # Interpolate EEM to match PARAFAC model
      message("Minor mismatch in background/MQL/MDL emission increments. Spline interpolating to match PARAFAC model.")
      MQL_eem <- conform_eem_to_pf_emvals(MQL_eem, pfmodel)
      message("Done!")
    }
    # Identify LoQ value after Agostino et al., 2021.
    MQL_eem_match <- as.data.frame(MQL_eem) %>%
      dplyr::filter(em == target_em, ex == target_ex)
    LoQ_val <- MQL_eem_match$value
    # Find samples that are below/above LoQ
    pfload_fmax <- extrpf_fmax_int(pfmodel = pfmodel, eemlist = eemlist, component = comp,
                                   denormalise = denormalise_loadings_MQL)
    pfload_fmax$above_LoQ <- ifelse(test = pfload_fmax[,2] > LoQ_val, yes = 1, no = 0)
  }
  ## SPECTRAL TRIMMING: PARAFAC spectra trimming if using constrain_comparison
  if(!isFALSE(constrain_comparison)){
    if(is.numeric(constrain_comparison)){
      if(constrain_comparison < 1 && constrain_comparison > 0){
        tol_bounds <- constrain_comparison
      }else {
        stop("If supplying a value for constrain_comparison, it must be between 0 and 1.")
      }
    } else {
      tol_bounds <- 0.03
      message("Percent tolerance for wavelength constraint set to 3% by default.")
    }
    loads <- list(mat_pf_ex_main,  mat_pf_em_main)
    # Generate normalised component modes
    norm_loads <- lapply(loads, function(x){
      normload <- data.matrix(x/max(x, na.rm = TRUE))
      rownames(normload) <- rownames(x)
      normload
    })
    # Generate boundaries
    comp_bounds <- lapply(norm_loads, function(var, bounds_tol = tol_bounds){
      wl_start_ind <- as.numeric(min(which(var > bounds_tol)))
      wl_start <- as.numeric(rownames(var)[min(which(var > bounds_tol))])
      var_reversed <- data.matrix(var[nrow(var):1,])
      wl_end_ind <- length(var) - as.numeric(min(which(var_reversed > bounds_tol)))
      wl_end <- as.numeric(rownames(var)[wl_end_ind])
      wl <- list(wl_start,wl_end) %>%
        'names<-'(c('start','end'))
      ind <- list(wl_start_ind,wl_end_ind) %>%
        'names<-'(c('start','end'))
      bnd_list <- list(wl,ind) %>%
        'names<-'(c('wavelengths','indices'))
      bnd_list
    })
    # Return constrained component matrices
    mat_pf_ex_main <- mat_pf_ex_main %>% data.frame() %>% rownames_to_column('wavelength') %>%
      slice(unlist(comp_bounds[[1]][[2]][1]):unlist(comp_bounds[[1]][[2]][2])) %>%
      column_to_rownames('wavelength') %>% data.matrix()
    mat_pf_em_main <- mat_pf_em_main %>% data.frame() %>% rownames_to_column('wavelength') %>%
      slice(unlist(comp_bounds[[2]][[2]][1]):unlist(comp_bounds[[2]][[2]][2])) %>%
      column_to_rownames('wavelength') %>% data.matrix()
  }
  # Fill SSC table
  types <- c("tcc","ssc","alpha","beta")
  cats <- c("excitation","emission")
  types_pst <- paste(rep(cats, each = length(types)), types, sep = "_")
  SSC_table <- data.frame(matrix(NA, nrow = length(eemlist), ncol = length(types_pst)))
  colnames(SSC_table) <- types_pst
  if(isTRUE(modified_metrics)){
    SSC_table$mSSC <- NA
    SSC_table$mTCC <- NA
  }
  SSC_table$sample <- unlist(lapply(eemlist,"[[","sample"))
  # Calculate metrics for each EEM.
  for(e in seq_along(eemlist)){
    # For this EEM, pull out the emission and excitation slices.
    target_eem <- eemlist[[e]]
    name <- target_eem$sample
    mat_pf_em <- mat_pf_em_main # reassign the pf spectra to ensure no modification between loops
    mat_pf_ex <- mat_pf_ex_main
    eem_slice <- slice_eem_int(eem = target_eem, ex = target_ex, em = target_em)
    mat_em_it <- eem_slice %>%
      dplyr::filter(name == "emission") %>%
      tibble::column_to_rownames('wavelength') %>%
      select(-2) %>%
      mutate_at(vars(intensity), as.numeric) %>%
      data.matrix()
    mat_ex_it <- eem_slice %>%
      dplyr::filter(name == "excitation") %>%
      tibble::column_to_rownames('wavelength') %>%
      select(-2) %>%
      mutate_at(vars(intensity), as.numeric) %>%
      data.matrix()
    # EEM Correction step 1: Removal of fluorescence contribution from non-target components; component spectral overlap correction.
    if(!is.null(spectral_correct)){
      if(!isFALSE(constrain_comparison)){
        if(spectral_correct == "ex"){
          mat_ex_it <- comp_correct_spectra(grob = grob_ex, sample_char = name, comp = comp, type = "ex", neg_to_0 = exclude_negative_residuals, bounds = comp_bounds)
        } else if(spectral_correct == "em"){
          mat_em_it <- comp_correct_spectra(grob = grob_em, sample_char = name, comp = comp, type = "em", neg_to_0 = exclude_negative_residuals, bounds = comp_bounds)
        } else if(spectral_correct == "all"){
          mat_ex_it <- comp_correct_spectra(grob = grob_ex, sample_char = name, comp = comp, type = "ex", neg_to_0 = exclude_negative_residuals, bounds = comp_bounds)
          mat_em_it <- comp_correct_spectra(grob = grob_em, sample_char = name, comp = comp, type = "em", neg_to_0 = exclude_negative_residuals, bounds = comp_bounds)
        } else {
          stop("Please specify spectral_correct as NULL, 'ex', 'em' or 'all'")
        }
      } else {
        if(spectral_correct == "ex"){
          mat_ex_it <- comp_correct_spectra(grob = grob_ex, sample_char = name, comp = comp, type = "ex", neg_to_0 = exclude_negative_residuals)
        } else if(spectral_correct == "em"){
          mat_em_it <- comp_correct_spectra(grob = grob_em, sample_char = name, comp = comp, type = "em", neg_to_0 = exclude_negative_residuals)
        } else if(spectral_correct == "all"){
          mat_ex_it <- comp_correct_spectra(grob = grob_ex, sample_char = name, comp = comp, type = "ex", neg_to_0 = exclude_negative_residuals)
          mat_em_it <- comp_correct_spectra(grob = grob_em, sample_char = name, comp = comp, type = "em", neg_to_0 = exclude_negative_residuals)
        } else {
          stop("Please specify spectral_correct as NULL, 'ex', 'em' or 'all'")
        }
      }
    }
    # Correction step 2: interpolation to 1nm bandwidth
    if(!isTRUE(interp_1nm)){
      if(interp_1nm == "ex"){
        mat_ex_it <- interpolate_matrix_1nm(mat = mat_ex_it, mat_out = TRUE)
      } else if(interp_1nm == "em"){
        mat_em_it <- interpolate_matrix_1nm(mat = mat_em_it, mat_out = TRUE)
      } else if(interp_1nm == "all"){
        mat_ex_it <- interpolate_matrix_1nm(mat = mat_ex_it, mat_out = TRUE)
        mat_em_it <- interpolate_matrix_1nm(mat = mat_em_it, mat_out = TRUE)
      } else {
        stop("Please specify interp_1nm as NULL, 'ex', 'em' or 'all'")
      }
    }
    # Correction step 3: smoothing with Savitzky-Golay filter
    if(!isTRUE(smooth_sg)){
      data("sg_terms_deftab") # default smoothing terms. Eventually tweakable (I hope)
      if(smooth_sg == "ex"){
        mat_ex_it <- sg_smooth(mat = mat_ex_it,  n = sg_terms_deftab['ex','n'], p = sg_terms_deftab['ex','p'], m = sg_terms_deftab['ex','m'], ts = sg_terms_deftab['ex','ts'])
      } else if(smooth_sg == "em"){
        mat_em_it <- sg_smooth(mat = mat_em_it,  n = sg_terms_deftab['em','n'], p = sg_terms_deftab['em','p'], m = sg_terms_deftab['em','m'], ts = sg_terms_deftab['em','ts'])
      } else if(smooth_sg == "all"){
        mat_ex_it <- sg_smooth(mat = mat_ex_it,  n = sg_terms_deftab['ex','n'], p = sg_terms_deftab['ex','p'], m = sg_terms_deftab['ex','m'], ts = sg_terms_deftab['ex','ts'])
        mat_em_it <- sg_smooth(mat = mat_em_it,  n = sg_terms_deftab['em','n'], p = sg_terms_deftab['em','p'], m = sg_terms_deftab['em','m'], ts = sg_terms_deftab['em','ts'])
      } else {
        stop("Please specify smooth_sg as NULL, 'ex', 'em' or 'all'")
      }
    }
    # Secondary peak handling. Gradient peak detection to remove incomplete peaks.
    if(!is.null(complete_peak)){
      # Note: if complete_peak is specified (i.e. not NULL), then the peak handling occurs in one of two ways, based upon the SSC_trim method var.
      if(SSC_trim_method == 'mod_alpha'){
        # The default (and recommended) method is to adjust the peak position calculation, rather than discarding spectra associated with an incomplete peak.
        if(complete_peak == "ex"){
          trough_val_ex <- extract_complete_peak(mat1 = mat_pf_ex, mat2 = mat_ex_it, return_trough = TRUE)
        } else if(complete_peak == "em"){
          trough_val_em <- extract_complete_peak(mat1 = mat_pf_em, mat2 = mat_em_it, return_trough = TRUE)
        } else if(complete_peak == "all"){
          trough_val_ex <- extract_complete_peak(mat1 = mat_pf_ex, mat2 = mat_ex_it, return_trough = TRUE)
          trough_val_em <- extract_complete_peak(mat1 = mat_pf_em, mat2 = mat_em_it, return_trough = TRUE)
        } else {
          stop("Please specify complete_peak as NULL, 'ex', 'em' or 'all'")
        }
      } else if(SSC_trim_method == 'trim_spectra'){
        # Alternatively, the 'original' method can be used, where incomplete peaks are simply removed altogether.
        if(complete_peak == "ex"){
          ex_mats <- extract_complete_peak(mat1 = mat_pf_ex, mat2 = mat_ex_it)
          mat_pf_ex <- ex_mats$mat1
          mat_ex_it <- ex_mats$mat2
        } else if(complete_peak == "em"){
          em_mats <- extract_complete_peak(mat1 = mat_pf_em, mat2 = mat_em_it)
          mat_pf_em <- em_mats$mat1
          mat_em_it <- em_mats$mat2
        } else if(complete_peak == "all"){
          em_mats <- extract_complete_peak(mat1 = mat_pf_em, mat2 = mat_em_it)
          mat_pf_em <- em_mats$mat1
          mat_em_it <- em_mats$mat2
          ex_mats <- extract_complete_peak(mat1 = mat_pf_ex, mat2 = mat_ex_it)
          mat_pf_ex <- ex_mats$mat1
          mat_ex_it <- ex_mats$mat2
        } else {
          stop("Please specify complete_peak as NULL, 'ex', 'em' or 'all'")
        }
      } else {
        stop("Please specify SSC_trim_method as 'mod_alpha' or 'trim_spectra'")
      }
    }
    # Populating SSC table.
    # SSC table handling
    if(SSC_trim_method == 'trim_spectra' || is.null(SSC_trim_method)){
      ## Use mats (trimmed or un-trimmed) to find the SSC value.
      ssc_more_em <-  ssc_more_int(mat_pf_em, mat_em_it, tcc = FALSE)
      tcc_em <- staRdom::ssc(mat_pf_em, mat_em_it, tcc = TRUE)
      ssc_more_ex <-  ssc_more_int(mat_pf_ex, mat_ex_it, tcc = FALSE)
      tcc_ex <- staRdom::ssc(mat_pf_ex, mat_ex_it, tcc = TRUE)
      SSC_table[e,c("excitation_tcc", "excitation_ssc", "excitation_alpha", "excitation_beta")] <- c(tcc_ex,ssc_more_ex[1],ssc_more_ex[2],ssc_more_ex[3])
      SSC_table[e,c("emission_tcc", "emission_ssc", "emission_alpha", "emission_beta")] <- c(tcc_em,ssc_more_em[1],ssc_more_em[2],ssc_more_em[3])
      if(isTRUE(modified_metrics)){
        SSC_table[e,'mSSC'] <- sqrt(as.numeric(ssc_more_ex['ssc',1]) * as.numeric(ssc_more_em['ssc',1]))
        SSC_table[e,'mTCC'] <- sqrt(as.numeric(tcc_ex) * as.numeric(tcc_em))
      }
    } else if(SSC_trim_method == 'mod_alpha'){
      # Modified alpha term calculation using the supplied trough value.
      # Depending on which spectra may be trimmed.
      if(complete_peak == "ex"){
        ssc_more_ex <- ssc_more_int(mat_pf_ex, mat_ex_it, tcc = FALSE, alpha_start = trough_val_ex)
        ssc_more_em <-  ssc_more_int(mat_pf_em, mat_em_it, tcc = FALSE)
      } else if(complete_peak == "em"){
        ssc_more_ex <- ssc_more_int(mat_pf_ex, mat_ex_it, tcc = FALSE)
        ssc_more_em <- ssc_more_int(mat_pf_em, mat_em_it, tcc = FALSE, alpha_start = trough_val_em)
      } else if(complete_peak == "all"){
        ssc_more_ex <- ssc_more_int(mat_pf_ex, mat_ex_it, tcc = FALSE, alpha_start = trough_val_ex)
        ssc_more_em <- ssc_more_int(mat_pf_em, mat_em_it, tcc = FALSE, alpha_start = trough_val_em)
      } else {
        stop("Please specify complete_peak as NULL, 'ex', 'em' or 'all'")
      }
      tcc_ex <- staRdom::ssc(mat_pf_ex, mat_ex_it, tcc = TRUE)
      tcc_em <- staRdom::ssc(mat_pf_em, mat_em_it, tcc = TRUE)
      SSC_table[e,c("excitation_tcc", "excitation_ssc", "excitation_alpha", "excitation_beta")] <- c(tcc_ex,ssc_more_ex[1],ssc_more_ex[2],ssc_more_ex[3])
      SSC_table[e,c("emission_tcc", "emission_ssc", "emission_alpha", "emission_beta")] <- c(tcc_em,ssc_more_em[1],ssc_more_em[2],ssc_more_em[3])
      if(isTRUE(modified_metrics)){
        # missing value handling to prevent the occurrence of positive value calculation were two negatives are supplied.
        if((ssc_more_ex['ssc',1] < 0) || (ssc_more_em['ssc',1] < 0) || (is.na(ssc_more_ex['ssc',1])) || (is.na(ssc_more_em['ssc',1]))){
          SSC_table[e,'mSSC'] <- NA
        } else {
          SSC_table[e,'mSSC'] <- sqrt(as.numeric(ssc_more_ex['ssc',1]) * as.numeric(ssc_more_em['ssc',1]))
        }
        if((as.numeric(tcc_ex) < 0) || (as.numeric(tcc_em) < 0) || (is.na(tcc_ex)) || (is.na(tcc_em))){
          SSC_table[e,'mTCC'] <- NA
        } else {
          SSC_table[e,'mTCC'] <- sqrt(as.numeric(tcc_ex) * as.numeric(tcc_em))
        }
      }
    }
    if(isTRUE(verbose)){
      message(name)
    }
    if(e %% 50 == 0){
      message("EEM ", e, " complete")
    }
  }
  if(!is.null(MQL_eem)){
    SSC_table$above_LoQ <- pfload_fmax$above_LoQ
  }
  message("Calculations complete")
  SSC_table
}

#' Generate average component-sample similarity score.
#'
#' @description Produce a simple average of PARAFAC component-sample similarity scores, with
#'        option for limit of quantification (LoQ) threshold.
#'
#' @param per_eem_ssc_res an output from per_eem_ssc
#' @param LoQ_threshold logical TRUE/FALSE. If TRUE, the function will only use scores for samples that exceed the LoQ. This will have been calculated previously if an MQL EEM object was supplied to the per_eem_ssc function.
#'
#' @importFrom dplyr filter
#'
#' @export
#'
combined_pessc_scores <- function(per_eem_ssc_res,
                                  LoQ_threshold = TRUE){
  # Input check
  if(isTRUE(LoQ_threshold)){
    # Apply LoQ threshold.
    if(!'above_LoQ' %in% colnames(per_eem_ssc_res)){
      # No LoQ values supplied.
      message("No LoQ threshold info in supplied results table. Defaulting to inclusion of all scores.")
      message("To exclude samples that exhibit per-component intensities below the LoQ, supply per_eem_ssc with an MDL EEM.")
      combined_vals <- data.frame(matrix(NA,nrow = 1, ncol = 3)) %>%
        'colnames<-'(c('mean_mSSC','mean_mTCC','pct_above_LoQ'))
      combined_vals[,'mean_mSSC'] <- mean(per_eem_ssc_res$mSSC, na.rm = T)
      combined_vals[,'mean_mTCC'] <- mean(per_eem_ssc_res$mTCC, na.rm = T)
      combined_vals
    } else {
      # LoQ values supplied.
      per_eem_ssc_res2 <- per_eem_ssc_res %>%
        dplyr::filter(above_LoQ == 1)
      # Generate combined values
      combined_vals <- data.frame(matrix(NA,nrow = 1, ncol = 3)) %>%
        'colnames<-'(c('mean_mSSC','mean_mTCC','pct_above_LoQ'))
      combined_vals[,'mean_mSSC'] <- mean(per_eem_ssc_res2$mSSC, na.rm = T)
      combined_vals[,'mean_mTCC'] <- mean(per_eem_ssc_res2$mTCC, na.rm = T)
      combined_vals[,'pct_above_LoQ'] <- (nrow(per_eem_ssc_res2)/nrow(per_eem_ssc_res))*100
      combined_vals
    }
  } else {
    # No LoQ parsing.
    combined_vals <- data.frame(matrix(NA,nrow = 1, ncol = 3)) %>%
      'colnames<-'(c('mean_mSSC','mean_mTCC','pct_above_LoQ'))
    combined_vals[,'mean_mSSC'] <- mean(per_eem_ssc_res$mSSC, na.rm = T)
    combined_vals[,'mean_mTCC'] <- mean(per_eem_ssc_res$mTCC, na.rm = T)
    combined_vals
  }
}

