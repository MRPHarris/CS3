# This file contains the main functions exported by the CS3 package.

#' Compare PARAFAC and EEM spectra with spectral similarity metrics
#'
#' @description Extract the spectra from a PARAFAC model (B and C mode loadings) and compare them with underlying
#'       sample data. Various options exist for corrections, including adjusting excitation spectra so that SSC might
#'       be applied rather than just TCC.
#'
#' @param pfmodel a PARAFAC model object. An output from staRdom::eem_parafac()
#' @param eemlist a group of EEMs compliant with the staRdom/EEM/eemR package framework
#' @param comp one or more components to extract information for. Can be numeric to index one or more components, or a character specifying an exact component. Character must be in the format "Comp.n" if used, where n is a component number.
#' @param MQL_eem an EEM object quantifying the Method Quantification Limit. Generated by suppling create_MQL_eem with an eemlist comprising ultrapure water blanks generated with the same instrument + method as the EEMs supplied to this function and the target PARAFAC model.
#' @param conform_eem TRUE/FALSE to attempt to remedy minor dimensional differences between EEMs and the PARAFAC model using spline interpolation. Computationally demanding as EEMs are also re-corrected for first order rayleigh scatter to prevent fluorescence at em < ex wavelengths.
#' @param denormalise_loadings_MQL was the pfmodel used here supplied with normalised EEMs, and do you wish to denormalised them? This requires the eemlist supplied to per_eem_ssc to be non-normalised.
#' @param tcc TRUE/FALSE to extract only TCC rather than SSC
#' @param terms TRUE/FALSE to extract the alpha and beta penalty term values alongside SSC
#' @param modified_metrics TRUE/FALSE to add the modified (ex + em combined) TCC and SSC metrics after Parr et al., 2014.
#' @param spectral_correct either NULL, 'all', 'ex', or 'em'. Subtract the loadings of other components from the raw sample spectra of the type specified. The fundamental performance of the CS3 approach relies on this being set to 'all', but this can be changed as needed depending upon the aims of the investigator.
#' @param interp_1nm either NULL, 'all', 'ex', or 'em'.  Interpolate spectra to 1nm bandwidths. Recommended. Applied after spectral correction
#' @param smooth_sg either NULL, 'all', 'ex', or 'em'. Applies a Savitzky-Golay filter to the data prior to metric calculation. Only recommended if interpolation is performed. Uses signal::sgolay(). Default values are a 2nd order polynomial, n = 21 for emission spectra and n = 11 for excitation spectra.
#' @param reverse_sg TRUE/FALSE to reverse input matrix prior to (and following) the SG smoothing. This may reduce the occurrence of short wavelength boundary artefacts.
#' @param complete_peak either NULL, 'all', 'ex', or 'em'. Use a gradient detection method to identify incomplete peaks in spectra, and prevent them from interfering with the SSC peak position calculation. Set options with the parameter 'SSC_trim_method'.
#' @param SSC_trim_method if !is.null(complete_peak), choose one of either 'mod_alpha' to alter the peak position penalty term, or 'trim_spectra' to remove the incomplete peak entirely.
#' @param verbose TRUE/FALSE to return various messages during the function's opperation. Useful for error checking or to keep track of how things are proceeding.
#' @param denormalise_residuals TRUE/FALSE to denormalise residuals using the max fluorescence value of the supplied eemlist. Default to FALSE. Use if you're supplying a PARAFAC model to the function that was generated with a normalised version of an eemlist, and comparing it with the non-normalised version of said eemlist.
#' @param exclude_negative_residuals TRUE/FALSE to set negative values to 0 during component overlap correction. Setting this to TRUE may inflate similarity scores in component:sample comparisons where the model has over-fitted the component.
#' @param constrain_comparison TRUE/FALSE or numeric decimal value between 0 and 1. A percentage threshold is used to identify the 'limit' of a component's fluorescence response, limiting spectral comparisons to within the normalised intensity boundary supplied.
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr select
#' @importFrom dplyr mutate_at
#' @importFrom dplyr vars
#' @importFrom dplyr filter
#' @importFrom utils data
#' @importFrom tibble column_to_rownames
#'
#' @export
#'

per_eem_ssc <- function(pfmodel,
                        eemlist,
                        comp,
                        MQL_eem = NULL,
                        conform_eems = TRUE,
                        denormalise_loadings_MQL = FALSE,
                        tcc = FALSE,
                        modified_metrics = TRUE,
                        spectral_correct = "all",
                        interp_1nm = "all",
                        smooth_sg = "all",
                        reverse_sg = TRUE,
                        complete_peak = "ex",
                        SSC_trim_method = 'mod_alpha',
                        verbose = FALSE,
                        denormalise_residuals = FALSE,
                        exclude_negative_residuals = FALSE,
                        constrain_comparison = FALSE){
  ## Input check for PARAFACF model
  if(!class(pfmodel) == 'parafac'){
    stop("please supply a pfmodel object. See ?staRdom::eem_parafac")
  }
  ## Explicitly specify comps to make iterations more straightforward
  if(is.null(comp)){
    # Have to allow for models where the 1st comp != comp 1.
    # Component indices
    comps = seq(1,ncol(pfmodel$A),1)
    # Component n
    actual_comps <- as.numeric(unlist(lapply(strsplit(colnames(pfmodel$A),"[.]"),"[[",2)))
    # Component list for later iteration
    comp_list = vector('list', length = length(comps)) %>% 'names<-'(c(paste0("Comp.",actual_comps)))
  } else {
    if(is.numeric(comp)){
      actual_comp <- colnames(pfmodel$A)[which(as.numeric(unlist(lapply(strsplit(colnames(pfmodel$A),"[.]"),"[[",2))) == comp)]
      # Component list for later iteration
      comps = comp
      comp_list = vector('list', length = length(comps)) %>% 'names<-'(c(actual_comp))
    } else if(!is.numeric(comp)){
      # literal component specification handling
      if(grepl("Comp.",comp)){
        complit = as.numeric(which(colnames(pfmodel$A) == comp))
        if(is_empty(complit)){
          stop(paste0("pfmodel does not contain '",comp,"'."))
        }
        # Use passing comp literal to name iteration list for later
        comp_list = vector('list', length = 1) %>% 'names<-'(c(paste0("Comp.",complit)))
        # Assign index to comp
        comps = complit
      } else {
        stop('comp must be either a numeric vector or NULL. More than one component may be specified, e.g. comp = c(1,3). If a character is supplied, it must match one of the components in the model using the format "Comp.n". You can use colnames(pfmodel$A) to check which components the model contains.')
      }
    }
  }
  ## PF PEAK SPECTRA
  # pf_peak_spectra_list <- vector('list', length(comp)) %>%
  #   'names<-'(paste0('Comp.',comp))
  # for(c in seq_along(pf_peak_spectra_list)){
  #   pf_peak_spectra_list[[c]] <- extrpf_peak_spectra_int(pfmodel, component = c)
  # }
  ## Dimchecks
  # The goal here is to determine whether there are dimensional differences between the PARAFAC model and EEMs.
  dimchecks <- data.frame(matrix(NA, nrow = length(eemlist), ncol = 1)) %>% 'rownames<-'(c(eem_names(eemlist))) %>% 'colnames<-'(c('dims_equal'))
  for(e in seq_along(eemlist)){
    dimcheck <- compare_dims_eem_pf(pfmodel, eemlist[[e]])
    if(all(dimcheck$Pass)){
      dimchecks[e,1] <- TRUE
    } else {
      dimchecks[e,1] <- FALSE
    }
  }
  if(!all(dimchecks$dims_equal)){
    message(length(which(!dimchecks$dims_equal)), " EEMs are not of equal dimensions to the PARAFAC model. This may cause problems with spectral corrections if left unremedied.")
  }
  # Now conform EEMs if specified.
  if(isTRUE(conform_eems)){
    if(verbose){
      message("Attempting to conform ",length(which(!dimchecks$dims_equal))," EEMs to the same dimensions as the PARAFAC model.")
    }
    conf_eems <- eemlist[which(!dimchecks$dims_equal)]
    for(adj in seq_along(conf_eems)){
      eem_it <- conf_eems[[adj]]
      conf_eems[[adj]] <- conform_eem_to_pf_emvals(eem = eem_it, pfmodel = pfmodel)
    }
    eemlist[which(!dimchecks$dims_equal)] <- conf_eems
    if(verbose){
      message("EEMs conformed to pfmodel.")
    }
  }
  ## Same for detection/quantification limit EEM object, if supplied.
  if(!is.null(MQL_eem)){
    if(class(MQL_eem) != 'eem'){
      stop('MQL_eem must be an object of class "eem"')
    }
    dimcheck <- compare_dims_eem_pf(pfmodel = pfmodel, eem = MQL_eem)
    if(!all(dimcheck$Pass)){
      message("Comparison of pfmodel and background/MQL/MDL EEM:")
      print(dimcheck)
      stop("!! PARAFAC model and MQL EEM exhibit ex/em differences, implying a difference in methods.")
    }
    # If they are sufficiently similar, but there is a minor difference in emission increments, we can forge ahead:
    if(!setequal(as.numeric(MQL_eem$em), as.numeric(rownames(pfmodel$B)))){
      # Interpolate EEM to match PARAFAC model
      message("Minor mismatch in background/MQL/MDL emission increments. Spline interpolating to match PARAFAC model.")
      MQL_eem <- conform_eem_to_pf_emvals(MQL_eem, pfmodel)
      message("Done!")
    }
  }
  ## PARAFAC MATS
  pf_comp_mats <- vector('list', length(comps)) %>%
    'names<-'(paste0('Comp.',comps))
  for(c in seq_along(pf_comp_mats)){
    pf_comp_mats[[c]] <- list(
      ex = as.matrix(pfmodel$C[,comps[[c]]]),
      em = as.matrix(pfmodel$B[,comps[[c]]])
    )
  }
  ## PARAFAC component matrix interpolation to 1nm, if specified.
  if(!is.null(interp_1nm)){
    if(isTRUE(verbose)){
      message("Interpolating PARAFAC spectra, type: ", interp_1nm)
    }
    pf_comp_mats <- lapply(pf_comp_mats, function(mats, opt = interp_1nm){
      if(opt == "ex"){
        mats[['ex']] <- interpolate_matrix_1nm(mat = mats[['ex']], mat_out = TRUE)
      } else if(opt == "em"){
        mats[['em']] <- interpolate_matrix_1nm(mat = mats[['em']], mat_out = TRUE)
      } else if(opt == "all"){
        mats <- lapply(mats, interpolate_matrix_1nm, mat_out = TRUE)
      }
      mats
    })
  }
  ## WHOLE-MODEL RESIDUALS EXTRACTIOn
  if(!is.null(spectral_correct)){
    if(isTRUE(verbose)){
      message("Extracting residuals data for component overlap correction...")
    }
    residuals <- extrpf_residuals_int(pfmodel = pfmodel, eem_list = eemlist, denormalise = denormalise_residuals, verbose = verbose)
    if(isTRUE(verbose)){
      message("Residuals extracted.")
    }
  }
  # Per-component iteration
  # comp_list <- vector('list',length = length(comp)) # Explicit component
  for(c in seq_along(comp_list)){
    comp = comps[c]
    # get PARAFAC spectra
    pf_peak_spectra <- extrpf_peak_spectra_int(pfmodel, component = comp)
    # get PARAFAC Emission 'B' mode - emission
    mat_pf_em_main <- as.matrix(pfmodel$B[,comp])
    # get PARAFAC Excitation 'C' mode - excitation
    mat_pf_ex_main <- as.matrix(pfmodel$C[,comp])
    # Get component peak coordinates
    target_em <- pf_peak_spectra$max_em[1]
    target_ex <- pf_peak_spectra$max_ex[1]
    # Get residuals grobs at these coordinates
    if(!is.null(spectral_correct)){
      grob_ex <- residuals[which(residuals$em == target_em),]
      grob_em <-  residuals[which(residuals$ex == target_ex),]
    }
    ## Per-component limit object handling
    # Identify LoQ value after Agostino et al., 2021.
    if(!is.null(MQL_eem)){
      MQL_eem_match <- as.data.frame(MQL_eem) %>%
        dplyr::filter(em == target_em, ex == target_ex)
      LoQ_val <- MQL_eem_match$value
      # Find samples that are below/above LoQ
      pfload_fmax <- extrpf_fmax_int(pfmodel = pfmodel, eemlist = eemlist, component = comp,
                                     denormalise = denormalise_loadings_MQL)
      pfload_fmax$above_LoQ <- ifelse(test = pfload_fmax[,2] > LoQ_val, yes = 1, no = 0)
    }
    ## SPECTRAL TRIMMING: PARAFAC spectra trimming if using constrain_comparison
    if(!isFALSE(constrain_comparison)){
      if(is.numeric(constrain_comparison)){
        if(constrain_comparison < 1 && constrain_comparison > 0){
          tol_bounds <- constrain_comparison
        }else {
          stop("If supplying a value for constrain_comparison, it must be a decimal percentage between 0 and 1.")
        }
      } else {
        tol_bounds <- 0.03
        message("Percent tolerance for wavelength constraint set to 3% by default.")
      }
      loads <- list(mat_pf_ex_main,  mat_pf_em_main)
      # Generate normalised component modes
      norm_loads <- lapply(loads, function(x){
        normload <- data.matrix(x/max(x, na.rm = TRUE))
        rownames(normload) <- rownames(x)
        normload
      })
      # Generate boundaries
      comp_bounds <- lapply(norm_loads, function(var, bounds_tol = tol_bounds){
        wl_start_ind <- as.numeric(min(which(var > bounds_tol)))
        wl_start <- as.numeric(rownames(var)[min(which(var > bounds_tol))])
        var_reversed <- data.matrix(var[nrow(var):1,])
        wl_end_ind <- length(var) - as.numeric(min(which(var_reversed > bounds_tol)))
        wl_end <- as.numeric(rownames(var)[wl_end_ind])
        wl <- list(wl_start,wl_end) %>%
          'names<-'(c('start','end'))
        ind <- list(wl_start_ind,wl_end_ind) %>%
          'names<-'(c('start','end'))
        bnd_list <- list(wl,ind) %>%
          'names<-'(c('wavelengths','indices'))
        bnd_list
      })
      # Return constrained component matrices
      mat_pf_ex_main <- mat_pf_ex_main %>% data.frame() %>% rownames_to_column('wavelength') %>%
        slice(unlist(comp_bounds[[1]][[2]][1]):unlist(comp_bounds[[1]][[2]][2])) %>%
        column_to_rownames('wavelength') %>% data.matrix()
      mat_pf_em_main <- mat_pf_em_main %>% data.frame() %>% rownames_to_column('wavelength') %>%
        slice(unlist(comp_bounds[[2]][[2]][1]):unlist(comp_bounds[[2]][[2]][2])) %>%
        column_to_rownames('wavelength') %>% data.matrix()
    }
    # Initialise SSC table
    SSC_table <- init_ssc_table(eemlist = eemlist, modified_metrics = modified_metrics)
    for(e in seq_along(eemlist)){
      # For this EEM, pull out the emission and excitation slices.
      target_eem <- eemlist[[e]]
      name <- target_eem$sample
      mat_pf_em <- mat_pf_em_main # reassign the pf spectra to ensure no modification between loops
      mat_pf_ex <- mat_pf_ex_main
      eem_slice <- slice_eem_int(eem = target_eem, ex = target_ex, em = target_em)
      mat_em_it <- eem_slice %>%
        dplyr::filter(name == "emission") %>%
        tibble::column_to_rownames('wavelength') %>%
        select(-2) %>%
        mutate_at(vars(intensity), as.numeric) %>%
        data.matrix()
      mat_ex_it <- eem_slice %>%
        dplyr::filter(name == "excitation") %>%
        tibble::column_to_rownames('wavelength') %>%
        select(-2) %>%
        mutate_at(vars(intensity), as.numeric) %>%
        data.matrix()
      # EEM Correction step 1: Removal of fluorescence contribution from non-target components; component spectral overlap correction.
      if(!is.null(spectral_correct)){
        if(!isFALSE(constrain_comparison)){
          if(spectral_correct == "ex"){
            mat_ex_it <- comp_correct_spectra(grob = grob_ex, sample_char = name, comp = comp, type = "ex", neg_to_0 = exclude_negative_residuals, bounds = comp_bounds)
          } else if(spectral_correct == "em"){
            mat_em_it <- comp_correct_spectra(grob = grob_em, sample_char = name, comp = comp, type = "em", neg_to_0 = exclude_negative_residuals, bounds = comp_bounds)
          } else if(spectral_correct == "all"){
            mat_ex_it <- comp_correct_spectra(grob = grob_ex, sample_char = name, comp = comp, type = "ex", neg_to_0 = exclude_negative_residuals, bounds = comp_bounds)
            mat_em_it <- comp_correct_spectra(grob = grob_em, sample_char = name, comp = comp, type = "em", neg_to_0 = exclude_negative_residuals, bounds = comp_bounds)
          } else {
            stop("Please specify spectral_correct as NULL, 'ex', 'em' or 'all'")
          }
        } else {
          if(spectral_correct == "ex"){
            mat_ex_it <- comp_correct_spectra(grob = grob_ex, sample_char = name, comp = comp, type = "ex", neg_to_0 = exclude_negative_residuals)
          } else if(spectral_correct == "em"){
            mat_em_it <- comp_correct_spectra(grob = grob_em, sample_char = name, comp = comp, type = "em", neg_to_0 = exclude_negative_residuals)
          } else if(spectral_correct == "all"){
            mat_ex_it <- comp_correct_spectra(grob = grob_ex, sample_char = name, comp = comp, type = "ex", neg_to_0 = exclude_negative_residuals)
            mat_em_it <- comp_correct_spectra(grob = grob_em, sample_char = name, comp = comp, type = "em", neg_to_0 = exclude_negative_residuals)
          } else {
            stop("Please specify spectral_correct as NULL, 'ex', 'em' or 'all'")
          }
        }
      }
      # Correction step 2: interpolation to 1nm bandwidth
      if(!isTRUE(interp_1nm)){
        if(interp_1nm == "ex"){
          mat_ex_it <- interpolate_matrix_1nm(mat = mat_ex_it, mat_out = TRUE)
        } else if(interp_1nm == "em"){
          mat_em_it <- interpolate_matrix_1nm(mat = mat_em_it, mat_out = TRUE)
        } else if(interp_1nm == "all"){
          mat_ex_it <- interpolate_matrix_1nm(mat = mat_ex_it, mat_out = TRUE)
          mat_em_it <- interpolate_matrix_1nm(mat = mat_em_it, mat_out = TRUE)
        } else {
          stop("Please specify interp_1nm as NULL, 'ex', 'em' or 'all'")
        }
      }
      # Correction step 3: smoothing with Savitzky-Golay filter
      if(!isTRUE(smooth_sg)){
        data("sg_terms_deftab") # default smoothing terms. Eventually tweakable (I hope)
        if(smooth_sg == "ex"){
          mat_ex_it <- sg_smooth(mat = mat_ex_it,  rev_spec = reverse_sg, n = sg_terms_deftab['ex','n'], p = sg_terms_deftab['ex','p'], m = sg_terms_deftab['ex','m'], ts = sg_terms_deftab['ex','ts'])
        } else if(smooth_sg == "em"){
          mat_em_it <- sg_smooth(mat = mat_em_it,  rev_spec = reverse_sg, n = sg_terms_deftab['em','n'], p = sg_terms_deftab['em','p'], m = sg_terms_deftab['em','m'], ts = sg_terms_deftab['em','ts'])
        } else if(smooth_sg == "all"){
          mat_ex_it <- sg_smooth(mat = mat_ex_it,  rev_spec = reverse_sg, n = sg_terms_deftab['ex','n'], p = sg_terms_deftab['ex','p'], m = sg_terms_deftab['ex','m'], ts = sg_terms_deftab['ex','ts'])
          mat_em_it <- sg_smooth(mat = mat_em_it,  rev_spec = reverse_sg, n = sg_terms_deftab['em','n'], p = sg_terms_deftab['em','p'], m = sg_terms_deftab['em','m'], ts = sg_terms_deftab['em','ts'])
        } else {
          stop("Please specify smooth_sg as NULL, 'ex', 'em' or 'all'")
        }
      }
      # Secondary peak handling. Gradient peak detection to remove incomplete peaks.
      if(!is.null(complete_peak)){
        # Note: if complete_peak is specified (i.e. not NULL), then the peak handling occurs in one of two ways, based upon the SSC_trim method var.
        if(SSC_trim_method == 'mod_alpha'){
          # The default (and recommended) method is to adjust the peak position calculation, rather than discarding spectra associated with an incomplete peak.
          if(complete_peak == "ex"){
            trough_val_ex <- extract_complete_peak(mat1 = mat_pf_ex, mat2 = mat_ex_it, return_trough = TRUE)
          } else if(complete_peak == "em"){
            trough_val_em <- extract_complete_peak(mat1 = mat_pf_em, mat2 = mat_em_it, return_trough = TRUE)
          } else if(complete_peak == "all"){
            trough_val_ex <- extract_complete_peak(mat1 = mat_pf_ex, mat2 = mat_ex_it, return_trough = TRUE)
            trough_val_em <- extract_complete_peak(mat1 = mat_pf_em, mat2 = mat_em_it, return_trough = TRUE)
          } else {
            stop("Please specify complete_peak as NULL, 'ex', 'em' or 'all'")
          }
        } else if(SSC_trim_method == 'trim_spectra'){
          # Alternatively, the 'original' method can be used, where incomplete peaks are simply removed altogether.
          if(complete_peak == "ex"){
            ex_mats <- extract_complete_peak(mat1 = mat_pf_ex, mat2 = mat_ex_it)
            mat_pf_ex <- ex_mats$mat1
            mat_ex_it <- ex_mats$mat2
          } else if(complete_peak == "em"){
            em_mats <- extract_complete_peak(mat1 = mat_pf_em, mat2 = mat_em_it)
            mat_pf_em <- em_mats$mat1
            mat_em_it <- em_mats$mat2
          } else if(complete_peak == "all"){
            em_mats <- extract_complete_peak(mat1 = mat_pf_em, mat2 = mat_em_it)
            mat_pf_em <- em_mats$mat1
            mat_em_it <- em_mats$mat2
            ex_mats <- extract_complete_peak(mat1 = mat_pf_ex, mat2 = mat_ex_it)
            mat_pf_ex <- ex_mats$mat1
            mat_ex_it <- ex_mats$mat2
          } else {
            stop("Please specify complete_peak as NULL, 'ex', 'em' or 'all'")
          }
        } else {
          stop("Please specify SSC_trim_method as 'mod_alpha' or 'trim_spectra'")
        }
      }
      # Populating SSC table.
      # SSC table handling
      if(SSC_trim_method == 'trim_spectra' || is.null(SSC_trim_method)){
        ## Use mats (trimmed or un-trimmed) to find the SSC value.
        ssc_more_em <-  ssc_more_int(mat_pf_em, mat_em_it, tcc = FALSE)
        tcc_em <- staRdom::ssc(mat_pf_em, mat_em_it, tcc = TRUE)
        ssc_more_ex <-  ssc_more_int(mat_pf_ex, mat_ex_it, tcc = FALSE)
        tcc_ex <- staRdom::ssc(mat_pf_ex, mat_ex_it, tcc = TRUE)
        SSC_table[e,c("excitation_tcc", "excitation_ssc", "excitation_alpha", "excitation_beta")] <- c(tcc_ex,ssc_more_ex[1],ssc_more_ex[2],ssc_more_ex[3])
        SSC_table[e,c("emission_tcc", "emission_ssc", "emission_alpha", "emission_beta")] <- c(tcc_em,ssc_more_em[1],ssc_more_em[2],ssc_more_em[3])
        if(isTRUE(modified_metrics)){
          SSC_table[e,'mSSC'] <- sqrt(as.numeric(ssc_more_ex['ssc',1]) * as.numeric(ssc_more_em['ssc',1]))
          SSC_table[e,'mTCC'] <- sqrt(as.numeric(tcc_ex) * as.numeric(tcc_em))
        }
      } else if(SSC_trim_method == 'mod_alpha'){
        # Modified alpha term calculation using the supplied trough value.
        # Depending on which spectra may be trimmed.
        if(complete_peak == "ex"){
          ssc_more_ex <- ssc_more_int(mat_pf_ex, mat_ex_it, tcc = FALSE, alpha_start = trough_val_ex)
          if(any(is.na(mat_em_it))){
            mat_em_it[is.na(mat_em_it)] <- 0
          }
          ssc_more_em <-  ssc_more_int(mat_pf_em, mat_em_it, tcc = FALSE)
        } else if(complete_peak == "em"){
          ssc_more_ex <- ssc_more_int(mat_pf_ex, mat_ex_it, tcc = FALSE)
          ssc_more_em <- ssc_more_int(mat_pf_em, mat_em_it, tcc = FALSE, alpha_start = trough_val_em)
        } else if(complete_peak == "all"){
          ssc_more_ex <- ssc_more_int(mat_pf_ex, mat_ex_it, tcc = FALSE, alpha_start = trough_val_ex)
          ssc_more_em <- ssc_more_int(mat_pf_em, mat_em_it, tcc = FALSE, alpha_start = trough_val_em)
        } else {
          stop("Please specify complete_peak as NULL, 'ex', 'em' or 'all'")
        }
        tcc_ex <- staRdom::ssc(mat_pf_ex, mat_ex_it, tcc = TRUE)
        tcc_em <- staRdom::ssc(mat_pf_em, mat_em_it, tcc = TRUE)
        SSC_table[e,c("excitation_tcc", "excitation_ssc", "excitation_alpha", "excitation_beta")] <- c(tcc_ex,ssc_more_ex[1],ssc_more_ex[2],ssc_more_ex[3])
        SSC_table[e,c("emission_tcc", "emission_ssc", "emission_alpha", "emission_beta")] <- c(tcc_em,ssc_more_em[1],ssc_more_em[2],ssc_more_em[3])
        if(isTRUE(modified_metrics)){
          # missing value handling to prevent the occurrence of positive value calculation were two negatives are supplied.
          if((ssc_more_ex['ssc',1] < 0) || (ssc_more_em['ssc',1] < 0) || (is.na(ssc_more_ex['ssc',1])) || (is.na(ssc_more_em['ssc',1]))){
            SSC_table[e,'mSSC'] <- NA
          } else {
            SSC_table[e,'mSSC'] <- sqrt(as.numeric(ssc_more_ex['ssc',1]) * as.numeric(ssc_more_em['ssc',1]))
          }
          if((as.numeric(tcc_ex) < 0) || (as.numeric(tcc_em) < 0) || (is.na(tcc_ex)) || (is.na(tcc_em))){
            SSC_table[e,'mTCC'] <- NA
          } else {
            SSC_table[e,'mTCC'] <- sqrt(as.numeric(tcc_ex) * as.numeric(tcc_em))
          }
        }
      }
      if(isTRUE(verbose)){
        message(name)
      }
      if(e %% 50 == 0){
        message("EEM ", e, " complete")
      }
    }
    if(!is.null(MQL_eem)){
      SSC_table$above_LoQ <- pfload_fmax$above_LoQ
    }
    message("Component ", comps[c], " complete")
    comp_list[[c]] <- SSC_table
  }
  comp_list
}

#' Generate average component-sample similarity score.
#'
#' @description Produce a simple average of PARAFAC component-sample similarity scores, with
#'        option for limit of quantification (LoQ) threshold.
#'
#' @param per_eem_ssc_res an output from per_eem_ssc
#' @param LoQ_threshold logical TRUE/FALSE. If TRUE, the function will only use scores for samples that exceed the LoQ. This will have been calculated previously if an MQL EEM object was supplied to the per_eem_ssc function.
#'
#' @importFrom dplyr filter
#'
#' @export
#'
combined_pessc_scores <- function(per_eem_ssc_res,
                                  LoQ_threshold = TRUE){
  # Input check
  if(isTRUE(LoQ_threshold)){
    # Apply LoQ threshold.
    if(!'above_LoQ' %in% colnames(per_eem_ssc_res)){
      # No LoQ values supplied.
      message("No LoQ threshold info in supplied results table. Defaulting to inclusion of all scores.")
      message("To exclude samples that exhibit per-component intensities below the LoQ, supply per_eem_ssc with an MDL EEM.")
      combined_vals <- data.frame(matrix(NA,nrow = 1, ncol = 3)) %>%
        'colnames<-'(c('mean_mSSC','mean_mTCC','pct_above_LoQ'))
      combined_vals[,'mean_mSSC'] <- mean(per_eem_ssc_res$mSSC, na.rm = T)
      combined_vals[,'mean_mTCC'] <- mean(per_eem_ssc_res$mTCC, na.rm = T)
      combined_vals
    } else {
      # LoQ values supplied.
      per_eem_ssc_res2 <- per_eem_ssc_res %>%
        dplyr::filter(above_LoQ == 1)
      # Generate combined values
      combined_vals <- data.frame(matrix(NA,nrow = 1, ncol = 3)) %>%
        'colnames<-'(c('mean_mSSC','mean_mTCC','pct_above_LoQ'))
      combined_vals[,'mean_mSSC'] <- mean(per_eem_ssc_res2$mSSC, na.rm = T)
      combined_vals[,'mean_mTCC'] <- mean(per_eem_ssc_res2$mTCC, na.rm = T)
      combined_vals[,'pct_above_LoQ'] <- (nrow(per_eem_ssc_res2)/nrow(per_eem_ssc_res))*100
      combined_vals
    }
  } else {
    # No LoQ parsing.
    combined_vals <- data.frame(matrix(NA,nrow = 1, ncol = 3)) %>%
      'colnames<-'(c('mean_mSSC','mean_mTCC','pct_above_LoQ'))
    combined_vals[,'mean_mSSC'] <- mean(per_eem_ssc_res$mSSC, na.rm = T)
    combined_vals[,'mean_mTCC'] <- mean(per_eem_ssc_res$mTCC, na.rm = T)
    combined_vals
  }
}

